{
  "engine" : "deal",
  "name" : "Create a deal between provider (node) and client",
  "cache" : 60000,
  "timeout" : 120000,
  "proposalListPrefix" : "bf70896b41c1555612fb332d274d4e4b",
  "cron" : 10,
  "TxidRegex" : "^[a-zA-Z0-9:.]+$",
  "claimDeadline" : 180,
  "asktxDeadline" : 10800,
  "purgeDeadline" : 10800,
  "retryPushTime" : 300,
  "txGracePeriod" : 120,
  "permissions":{
    "nodeKeys":true
  },
  "conf" :{
    "enabled" : {"default": false,"type": "boolean", "requiresRestart": true},
    "ledgers" : {"default": [], "type": "array", "requiresRestart": true}
  },
  "expose" : {
    "allocation" : ["readHistory"]
  },
  "quartz" : {
    "ledgerExceptions/fromBase/toSymbol/amount/target" : [
      "flow toSymbol {xrp:@xrp} @success",
      "@success",
      "done 'No ledger exceptions'",
      "@xrp",
      "true '$amount >= 20' @success",
      "void target null @success 1",
      "rout /a/$toSymbol/balance/$target 1 @failure",
      "true '($ + $amount) >= 20' @success",
      "fail 'Ripple requires an activation balance! Either swap 20 XRP or more to activate target.'",
      "@failure",
      "fail 'Error handling determine ledger exceptions for $toSymbol!'"
    ],
    "cron" : [
      "call proposalHandler",
      "void 2 1",
      "logs"
    ],
    "pairs" : [
      "call allocation::listPair/*",
      "each pairsEach $conf::ledgers",
      "excl null",
      "sort"
    ],
    "pairsEach" : [
      "with pair [data,'${.value}'] [splt,':']",
      "peek .meta",
      "poke ledgers",
      "with nativeA [data,'${pair[0]}'] [splt,'.'] [pick]",
      "indx '$nativeA'",
      "true '> -1' 2 1",
      "done null",
      "peek ledgers",
      "with nativeB [data,'${pair[1]}'] [splt,'.'] [pick]",
      "indx '$nativeB'",
      "true '> -1' 1 -4",
      "done '${pair[0]}:${pair[1]}'"
    ],
    "estimate/fromBase/toSymbol/amount" : [
      "time 30000",
      "call proposalCreate/$fromBase/$toSymbol/$amount"
    ],
    "proposal/fromBase/toSymbol/amount/target" : [
      "time 60000",
      "call proposalCreate/$fromBase/$toSymbol/$amount/$target"
    ],
    "proposalHandler" : [
      "call selectFromProposalList",
      "void 'void' @notexist",
      "poke proposalKey",
      "load $proposalKey 1 @removeFromQueue",
      "decr 1 @removeFromQueue",
      "jpar 1 @removeFromQueue",
      "have .accountID 1 @removeFromQueue",
      "poke accountID ${.accountID}",
      "# check if end-user has sent their transaction, and what the status is",
      "call dealStatus",
      "poke proposalID ${.id}",
      "with deadline [data,${.deadline}] [ship,2,1,1,1] [done,0]",
      "with timeNow date now",
      "with txStasis [date,now] [true,'> ($deadline + $purgeDeadline)',1,2] [done,1] [done,0]",
      "with txTimeout [data,${.status}] [flow,'timeout',1,2] [done,1] [done,0]",
      "with txRejected [data,${.status}] [flow,'rejected',1,2] [done,1] [done,0]",
      "with txDone [data,${.status}] [flow,'done',2,1] [done,0] [true,'${.progress} == 1',1,-1] [done,1]",
      "test txDone @removeFromQueue",
      "with typeAuto [data,${.type}] [flow,'autonomous',1,2] [done,1] [done,0]",
      "test typeAuto 1 @defer",
      "with txConfirmed [data,${.bid.txid}] [void,2,1] [done,0] [data,${.status}] [flow,'accepted',2,1] [done,0] [true,'${.progress} == 0.5',1,-1] [done,1]",
      "test txConfirmed 1 @defer",
      "# here we make sure transaction push retries do not happen too fast",
      "void .pushtime any @pushTx 1",
      "true '(${.pushtime} + $retryPushTime) < $timeNow' @pushTx @deferPush",
      "@pushTx",
      "with pushRecord call remitted/$proposalID/_",
      "data [$accountID,${.bid.symbol},${.bid.amount},${.bid.target}]",
      "jstr",
      "encr",
      "hook @deferPush",
      "call allocation::push",
      "call remitted/$proposalID/$",
      "done",
      "@deferPush",
      "test txStasis @removeFromQueueNoReserveUnlock",
      "done 'proposal $proposalID has a deferred remittance'",
      "@defer",
      "test txStasis @removeFromQueueNoReserveUnlock",
      "test txTimeout @removeFromQueueWithRebalance",
      "test txRejected @removeFromQueueWithRebalance",
      "with report [void,proposalID,any,2,1] [done,'proposal $proposalID with status ${.status} is pending...'] [done,null]",
      "done $report",
      "@removeFromQueueWithRebalance",
      "with rebalanceValue [math,'${.bid.amount} + ${.fees.network}']",
      "fork rebalanceCall/$accountID/${.bid.symbol}/$rebalanceValue",
      "@removeFromQueue",
      "fork securityReserveLock/$accountID/$proposalID/unlock",
      "@removeFromQueueNoReserveUnlock",
      "call deleteFromProposalList/$proposalKey",
      "with itemSpec [data,$proposalID] [void,any,1,2] [done,'storage key $proposalKey'] [done,'proposal $proposalID']",
      "done '$itemSpec removed from queue'",
      "@notexist",
      "done null"
    ],
    "proposalCreate/fromBase/toSymbol/amount/target=null" : [
      "time 60000",
      "ship amount 3 1 1 2",
      "fail 'Proposal amount must be higher than zero!'",
      "poke amount 1",
      "poke reference $amount",
      "call ledgerExceptions/$fromBase/$toSymbol/$amount/$target",
      "time 40000",
      "# 0. check if ledgers systems are available",
      "peek conf::ledgers []",
      "with fromNativeBase [data,'$fromBase'] [case,lower] [splt,'.'] [pick]",
      "indx '$fromNativeBase'",
      "true '> -1' 1 @unavailable",
      "peek conf::ledgers []",
      "with toNativeSymbol [data,'$toSymbol'] [case,lower] [splt,'.'] [pick]",
      "indx '$toNativeSymbol'",
      "true '> -1' @supported @unavailable",
      "@unavailable",
      "fail 'Swap pair is unavailable or undergoing maintenance!'",
      "@supported",
      "# 1. find best allocator available for this proposal",
      "flow target null 1 @hasTarget   # if estimating, take a fractional amount",
      "with toUnit rout /e/valuations/rate/usdt/$toSymbol/1",
      "poke amount $toUnit",
      "@hasTarget",
      "rout /e/allocation/pair/select/$fromBase/$toSymbol/$amount",
      "have .accountID 2 1",
      "fail 'Proposal cannot continue: No allocator accepts this proposal!'",
      "poke allocation",
      "with allocation.fee [excl,'%']",
      "# 2. gather some extra variables",
      "with timestamp [date,now] [math,'round']",
      "# 3. get conversion rate",
      "rout /e/valuations/rate/$toSymbol/$fromBase/1 2 1",
      "fail 'Proposal cannot continue: Cannot calculate conversion rate!'",
      "poke rate",
      "# 4. calculate conversion",
      "call calcNetworkFeesBaseDenominated/$fromBase/$toSymbol",
      "void 1 2",
      "fail 'Proposal cannot continue: Cannot get network fee data!'",
      "poke networkFee",
      "with allocatorFee [math,'$amount * $rate * (${allocation.fee} / 100)']",
      "with feesTotal math '$allocatorFee + $networkFee/($reference/$amount)'",
      "with baseAmount [math,'$amount * $rate']",
      "with baseAmountPlusFee [math,'$baseAmount + $feesTotal']",
      "# ! include maximum tradable amounts",
      "with maxBidSufficiency [rout,/e/allocation/pair/stats/$fromBase/$toSymbol,2,1] [done,0] [tran,.[$fromBase:$toSymbol].sufficiency,1,-1] [math,'/ $rate'] [form,$toSymbol]",
      "with maxAskSufficiency [math,'$maxBidSufficiency * $rate'] [form,$fromBase]",
      "# !  skip reserving amount and defining creation, deadline and recipient values if only estimating",
      "flow target null @estimateProposal 1",
      "# Validate target address",
      "rout /a/$toSymbol/validate/$target 2 1",
      "fail 'Could not validate target address'",
      "flow valid 2 1",
      "fail 'Target $target is not a valid $toSymbol address.'",
      "with creation [date,now] [math,round]",
      "with deadline math '$creation + $claimDeadline' round",
      "# 5. return target to accept payment, reserve needed amounts, and adjust feelevel",
      "with recipient call allocation::getAddressAccount/${allocation.accountID}/$fromBase",
      "fork rebalanceCall/${allocation.accountID}/$toSymbol/-$amount",
      "# 6. define proposal/estimate contents",
      "@estimateProposal",
      "poke proposalData { ask: {symbol:'$fromBase',amount:'$baseAmountPlusFee',sufficiency:'$maxAskSufficiency'}, bid: {symbol:'$toSymbol',amount:'$amount',sufficiency:'$maxBidSufficiency'}, fees: {symbol:'$fromBase',allocator:'$allocatorFee',network:'$networkFee'} }",
      "flow target null 1 @saveProposal",
      "with proposalData.ask.amount [math,'* ($reference / $toUnit)'] [form,$fromBase]",
      "with proposalData.bid.amount [math,'* ($reference / $toUnit)'] [form,$toSymbol]",
      "with proposalData.fees.allocator [math,'* ($reference / $toUnit)'] [form,$fromBase]",
      "done $proposalData",
      "# 7. finalize, save and return proposal object",
      "@saveProposal",
      "with proposalData.ask.amount form $fromBase",
      "with proposalData.bid.amount form $toSymbol",
      "with proposalData.fees.allocator form $fromBase",
      "poke [proposalData.type,proposalData.ask.target,proposalData.bid.target,proposalData.ask.txid,proposalData.bid.txid] ['${allocation.type}','$recipient','$target',null,null]",
      "with proposalIDa [data,'deal ${allocation.accountID} $fromBase $baseAmountPlusFee $recipient'] [hash,djb2] [case,lower]",
      "with proposalIDb [data,'deal ${allocation.accountID} $toSymbol $amount $target $deadline'] [hash,djb2] [case,lower]",
      "poke proposal { id: '${proposalIDa}${proposalIDb}', ask: ${proposalData.ask}, bid: ${proposalData.bid}, fees: ${proposalData.fees}, type: ${proposalData.type}, creation:$creation, deadline:$deadline, pushtime:null }",
      "data { accountID: '${allocation.accountID}', timestamp: $timestamp, deal: $proposal }",
      "jstr",
      "encr",
      "with keyHash [data,'deal ${allocation.accountID}'] [hash] [take,-16] [push,'$proposalIDb',0] [push,'$proposalIDa',0]",
      "save $keyHash",
      "fork securityReserveLock/${allocation.accountID}/${proposal.id}/lock",
      "fork addToProposalList/$keyHash",
      "done $proposal"
    ],
    "addToProposalList/key" : [
      "peek local::proposalList []",
      "push $key",
      "uniq",
      "poke local::proposalList"
    ],
    "selectFromProposalList" : [
      "with listSize [peek,local::proposalList,[]] [size]",
      "true '$listSize == 0' @finished",
      "with listCount [peek,local::proposalCount,0]",
      "true '$listCount < $listSize' 2 1",
      "poke listCount 0",
      "peek local::proposalList",
      "pick $listCount",
      "with listCount [math,'+1'] [poke,local::proposalCount]",
      "@finished"
    ],
    "deleteFromProposalList/key" : [
      "peek local::proposalList []",
      "excl $key",
      "uniq",
      "poke local::proposalList",
      "# add to the completed deals list",
      "call addToCompleteList/$key"
    ],
    "requeueToProposalList/key" : [
      "call addToProposalList/$key",
      "call deleteFromCompleteList/$key"
    ],
    "addToCompleteList/key" : [
      "peek local::completeList []",
      "push $key 0",
      "uniq",
      "poke local::completeList"
    ],
    "deleteFromCompleteList/key" : [
      "peek local::completeList []",
      "excl $key",
      "uniq",
      "poke local::completeList"
    ],
    "calcNetworkFeesBaseDenominated/source/target" : [
      "rout /a/$target/details",
      "poke targetFee ${.fee}",
      "with targetFeeSymbol [data,${.fee-symbol}] [splt,'.'] [pick,-1]",
      "with denominatedFeeSymbol [data,$source] [splt,'.'] [pick,-1]",
      "# recalculate target network fee into source network denomination",
      "rout /e/valuations/rate/$targetFeeSymbol/$denominatedFeeSymbol/$targetFee 2 1",
      "done null"
    ],
    "getProposal/proposalID" : [
      "list $proposalID*",
      "pick",
      "poke key",
      "test 1 @failure",
      "load 1 @failure",
      "decr 1 @failure",
      "jpar 1 @failure",
      "poke .key $key",
      "done",
      "@failure",
      "fail 'Proposal $proposalID cannot be read!'"
    ],
    "claim/proposalID/transactionID" : [
      "time 60000",
      "peek transactionID",
      "regx '$TxidRegex' 2 1",
      "fail 'Transaction ID must be in alphanumeric or hybrix format!'",
      "peek local::claimList []",
      "find $transactionID @submitted",
      "with listSize [data,$] [size]",
      "true '$listSize < 250' 2",
      "take -1",
      "push $transactionID 0",
      "uniq",
      "poke local::claimList",
      "call getProposal/$proposalID",
      "test .deal.ask.txid @submitted",
      "poke .deal.ask.txid $transactionID",
      "poke keyHash ${.key}",
      "drop key",
      "jstr",
      "encr",
      "save $keyHash",
      "done 'Claim for $proposalID submitted'",
      "@submitted",
      "fail 'Claim for $proposalID already submitted!'"
    ],
    "remitted/proposalID/transactionID" : [
      "time 60000",
      "with timeNow [date,now] [math,'round']",
      "call getProposal/$proposalID",
      "poke .deal.pushtime '$timeNow'",
      "test .deal.bid.txid 1 2",
      "fail 'already pushed remittance transaction for $proposalID!'",
      "flow transactionID '_' @onlySetTime 1",
      "poke .deal.bid.txid $transactionID",
      "poke askAmount ${.deal.ask.amount}",
      "poke bidAmount ${.deal.ask.amount}",
      "jump @saveData",
      "@onlySetTime",
      "poke .deal.bid.txid null",
      "@saveData",
      "poke keyHash ${.key}",
      "drop key",
      "jstr",
      "encr",
      "save $keyHash",
      "flow transactionID '_' 1 2",
      "done 'no remittance transaction pushed for $proposalID!'",
      "fork rebalanceCall/${allocation.accountID}/$fromBase/$askAmount",
      "fork rebalanceCall/${allocation.accountID}/$toSymbol/$bidAmount",
      "fork securityReserveLock/${allocation.accountID}/$proposalID/unlockWithFee",
      "done 'pushed remittance transaction for $proposalID'"
    ],
    "rebalanceCall/allocationID/symbol/amount" : [
      "call allocation::doRebalancePair/$allocationID/$symbol/$amount"
    ],
    "securityReserveLock/accountID/proposalID/action" : [
      "call getProposal/$proposalID",
      "void 1 2",
      "fail 'proposal $proposalID does not exist!'",
      "rout /e/valuations/rate/${.deal.ask.symbol}/hy/${.deal.ask.amount}",
      "ship @lockAmount @lockAmount 1 1",
      "warn 'Cannot $action security reserve amount on account $accountID!'",
      "fail 'Cannot $action security reserve amount on account $accountID!'",
      "@lockAmount",
      "call allocation::securityReserveAccountLock/$accountID/$action/$"
    ],
    "addressMatches/$target1/$target2" :[
      "call decodeUnifiedAddress/$target1",
      "indx '$target2'",
      "true '> -1' 1 2",
      "done 1",
      "done 0"
    ],
    "dealStatus": [
      "time 60000",
      "with disputed [root,1,3] [data,${.dispute}] [void,any,1,2] [done,null] [done] [data,${.dispute.level}] [ship,2,2,1,1] [done,null]",
      "tran .deal 1 @failure",
      "void .creation any @failure 1",
      "poke dealID ${.id}",
      "test .ask.txid 1 @zeroAskProgress",
      "with askTx [rout,/a/${.ask.symbol}/transaction/${.ask.txid},2,1] [done,null]",
      "test askTx.timestamp 1 @zeroAskProgress",
      "# is our transaction target equal to the claimed target?",
      "with targetEqual call addressMatches/${.ask.target}/${askTx.target}",
      "# is the transaction timestamp set before the proposal creation time?",
      "with txPremature [ship,askTx.timestamp,1,3,3,3] [true,'${askTx.timestamp} < (${.creation} - $txGracePeriod)',1,2] [done,1] [done,0]",
      "# reject the transaction if either premature or non-equal target",
      "with txRejected [true,'$txPremature',1,2] [done,1] [true,'${.ask.amount} > 0 and ${.bid.amount} > 0 and $targetEqual and ${askTx.amount} == ${.ask.amount}',1,-1] [done,0]",
      "#DEBUG: logs ' >>> equal:$targetEqual premature:$txPremature reject:$txRejected amountA:${askTx.amount} amountB:${.ask.amount}'",
      "true '$txRejected' @zeroAskProgress",
      "with askConfirmsMax rout /a/${.ask.symbol}/confirmed",
      "with askConfirmsNow [rout,/a/${.ask.symbol}/confirmed/${.ask.txid},2,1] [done,0]",
      "with askProgress math 'max($askConfirmsNow / $askConfirmsMax, 1)'",
      "jump @calcBidProgress",
      "@zeroAskProgress",
      "poke askProgress 0",
      "@calcBidProgress",
      "test .bid.txid 3",
      "poke bidProgress 0",
      "jump @finalize",
      "with bidConfirmsMax rout /a/${.bid.symbol}/confirmed",
      "with bidConfirmsNow [rout,/a/${.bid.symbol}/confirmed/${.bid.txid},2,1] [done,0]",
      "with bidProgress math 'max(($bidConfirmsNow / $bidConfirmsMax) + 0.05, 1)'",
      "@finalize",
      "poke .disputed $disputed",
      "with progress call calculateAndSaveProgress/$dealID/$askProgress/$bidProgress",
      "# without proper blockchain-based timestamp keep the deal pending",
      "with progress [true,'< 0.05',1,5] [data,${.ask.txid}] [void,1,2] [done,0] [data,'0.025'] [true,'< 0',1,2] [done,0] [true,'> 1',1,2] [done,1]",
      "poke .progress $progress",
      "with timenow date now",
      "with deadline math '${.creation} + $claimDeadline'",
      "with status [data,'stasis'] [true,'$txRejected',1,2] [done,'rejected'] [true,'$progress >= 1',1,2] [done,'done'] [true,'$progress == 0 and $deadline < $timenow',1,2] [done,'timeout'] [true,'$progress > 0 and $progress <= 0.025',1,2] [done,'claimed'] [true,'$progress > 0.025 and $progress < 0.5',1,2] [done,'confirming'] [true,'$progress == 0.5',1,2] [done,'accepted'] [true,'$progress >= 0.5 and $progress < 1',1,2] [done,'remitting'] [done,'open']",
      "poke .status $status",
      "done",
      "@failure",
      "done null"
    ],
    "calculateAndSaveProgress/dealID/askProgress/bidProgress" : [
      "with keyHash [data,'deal progress ${dealID}'] [hash]",
      "load $keyHash 1 @skipcompare",
      "jpar 1 @skipcompare",
      "poke savedProgress",
      "with askProgress math 'min( (round( max($askProgress,${savedProgress.ask})*10000 ) / 10000) ,1)'",
      "with bidProgress math 'min( (round( max($bidProgress,${savedProgress.bid})*10000 ) / 10000) ,1)'",
      "@skipcompare",
      "data {ask:$askProgress,bid:$bidProgress}",
      "save $keyHash",
      "math 'round(($askProgress + $bidProgress) / 0.0002) / 10000'"
    ],
    "status/proposalID" : [
      "call getProposal/$proposalID",
      "call dealStatus",
      "void @failure",
      "done",
      "@failure",
      "fail 'Cannot read proposal data of $proposalID!'"
    ],
    "dispute/proposalID/transactionID=null" : [
      "call getProposal/$proposalID",
      "poke keyHash ${.key}",
      "# check if proposal deadline has passed + 2 hours",
      "with timeNow [date,now] [math,round]",
      "with waitHours math 'round($purgeDeadline / 3600)'",
      "root 3 1",
      "true '(${.deal.deadline} + $purgeDeadline) > $timeNow' 1 2",
      "fail 'The deal you are trying to dispute is still pending! Please wait $waitHours hours for it to finalize, before disputing again.'",
      "# is this a new dispute?",
      "#void .dispute any @newDispute @alreadyDisputed",
      "@newDispute",
      "poke .dispute {level:1,timestamp:$timeNow,txid:$transactionID,comment:$@}",
      "with .dispute.comment [take,3] [join,'/']",
      "with .deal.deadline math '$timeNow+3600'",
      "jump @saveData",
      "@alreadyDisputed",
      "# was this recently disputed?",
      "void .dispute.timestamp any @newDispute 1",
      "true '${.dispute.timestamp} + $purgeDeadline < $timeNow' 2 1",
      "fail 'This deal has already been disputed! To escalate the dispute, please wait $waitHours hours, and then file another dispute.'",
      "poke .dispute.timestamp $timeNow",
      "# check the dispute level",
      "void .dispute.level any @newDispute 1",
      "with .dispute.level math '+1'",
      "fail 'Dispute cannot be escalated! This has not been implemented yet.'",
      "@escalation",
      "# write dispute status",
      "@saveData",
      "drop key",
      "jstr",
      "encr",
      "save $keyHash",
      "# requeue deal",
      "call requeueToProposalList/$keyHash",
      "done 'Dispute for $proposalID submitted'"
    ],
    "readHistory/timeOffset/timeLimit" : [
      "with timeUntil [date,now] [math,'- $timeOffset']",
      "with timeFrom math '$timeUntil - $timeLimit'",
      "peek local::completeList []",
      "each readHistoryObject/$timeFrom/$timeUntil",
      "excl null"
    ],
    "readHistoryObject/timeFrom/timeUntil" : [
      "load ${.value} 2 1",
      "done null",
      "decr 1 -1",
      "jpar 1 -2",
      "true '${.timestamp} >= $timeUntil or ${.timestamp} < $timeFrom' -3"
    ],
    "decodeUnifiedAddress/address" : [
      "hook @notUnifiedAddress",
      "rout /e/unified-asset/decompress/undefined/$address",
      "done",
      "@notUnifiedAddress",
      "peek address"
    ],
    "deal.js" : [
      "serv modules/deal/deal.js"
    ],
    "swap" : [
      "serv modules/deal/deal.html"
    ]
  },
  "router" : {
    "_help" : "Deal engine for deals between node and clients.",
    "deal.js":{
      "_this" : "Client side code for swap overview generation",
      "hidden" : true
    },
    "swap" : {
      "_this":"Swap Web UI.",
      "_ui" : "deal/swap"
    },
    "pairs": "List swappable pairs.",
    "estimate": {
      "_help" : "Estimate a deal.",
      "_ref" : {
        "_list" : "base",
        "_help" : "Specify the base symbol to offer in trade.",
        "_ref" : {
          "_help" : "Specify the desired symbol to receive units in.",
          "_list" : "symbol",
          "_this" : "symbol",
          "_ref" : {
            "_help" : "Specify the amount of base symbol to trade.",
            "_list" : "amount",
            "_this" : "amount"
          }
        }
      }
    },
    "proposal" : {
      "_help" : "Propose a deal to trade on.",
      "_ref" : {
        "_list" : "base",
        "_help" : "Specify the base symbol to offer in trade.",
        "_ref" : {
          "_help" : "Specify the desired symbol to receive units in.",
          "_list" : "symbol",
          "_ref" : {
            "_help" : "Specify the amount of base symbol to trade.",
            "_list" : "amount",
            "_ref" : {
              "_help" : "The target address at which to receive the incoming amount.",
              "_list" : "target",
              "_this" : "target"
            }
          }
        }
      }
    },
    "claim" : {
      "_help" : "Claim payment proof for proposal ID. Necessary for a swap to complete, and adds security to the swap.",
      "_ref" : {
        "_list" : "proposalID",
        "_help" : "Specify the proposal ID to call the claim for.",
        "_ref" : {
          "_list" : "transactionID",
          "_this" : "The transaction ID which shall contain the proof."
        }
      }
    },
    "status" : {
      "_help" : "Check the status of a proposal or deal.",
      "_ref" : {
        "_list" : "proposalID",
        "_this" : "Specify the proposal or deal ID to check the status of."
      }
    },
    "dispute" : {
      "_help" : "Dispute a deal.",
      "_ref" : {
        "_list" : "proposalID",
        "_ellipsis" : true,
        "_this" : "Specify the deal ID to dispute."
      }
    }
  }
}
